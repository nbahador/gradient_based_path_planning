<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient-Based Path Planning: Interactive Multi-Goal Pathfinding</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #64ffda;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.3);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        .visualization-panel {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #64ffda;
            box-shadow: 0 0 30px rgba(100, 255, 218, 0.2);
        }
        
        .math-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 255, 218, 0.3);
            max-height: 800px;
            overflow-y: auto;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            font-size: 12px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        label {
            color: #64ffda;
            font-weight: bold;
            min-width: 60px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 80px;
        }
        
        canvas {
            display: block;
            border-radius: 8px;
            background: #111;
        }
        
        .math-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(100, 255, 218, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        .math-title {
            color: #64ffda;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .formula {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 8px 0;
            font-size: 13px;
            border-left: 3px solid #64ffda;
        }
        
        .values-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .value-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
        }
        
        .value-label {
            color: #aaa;
            font-size: 10px;
        }
        
        .value-number {
            color: #64ffda;
            font-weight: bold;
            font-size: 14px;
        }
        
        .trajectory-colors {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }
        
        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .status {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #64ffda;
            font-weight: bold;
        }
        
        .phase-indicator {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .phase-name {
            color: #ffe66d;
            font-weight: bold;
            font-size: 16px;
        }
        
        .phase-description {
            color: #ccc;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        
        .control-group-title {
            color: #64ffda;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>✨ Enhanced Gradient-Based Path Planning with Interactive Controls</h1>
        
        <div class="main-content">
            <div class="visualization-panel">
                <div class="controls">
                    <div class="control-group">
                        <div class="control-group-title">🔧 Main Controls</div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button id="startBtn">Start All Scenarios</button>
                            <button id="resetBtn">Reset</button>
                            <button id="showGradientBtn">Toggle Gradient</button>
                            <button id="showParticlesBtn">Toggle Particles</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-group-title">⚙️ Simulation Parameters</div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <div class="slider-container">
                                <label>Noise:</label>
                                <input type="range" id="noiseSlider" min="0" max="100" value="80">
                                <span id="noiseValue">80%</span>
                            </div>
                            
                            <div class="slider-container">
                                <label>Speed:</label>
                                <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="3">
                                <span id="speedValue">3x</span>
                            </div>
                            
                            <div class="slider-container">
                                <label>Goal Attr:</label>
                                <input type="range" id="goalAttractionSlider" min="1" max="10" value="5">
                                <span id="goalAttractionValue">5x</span>
                            </div>
                            
                            <div class="slider-container">
                                <label>Particles:</label>
                                <input type="range" id="particlesSlider" min="10" max="300" value="80">
                                <span id="particlesValue">80</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-group-title">🛠️ Environment Tools</div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button id="addObstacleBtn">Add Obstacle</button>
                            <button id="removeObstacleBtn">Remove Obstacle</button>
                            <button id="addGoalBtn">Add Goal</button>
                            <button id="clearGoalsBtn">Clear Goals</button>
                        </div>
                    </div>
                </div>
                
                <div class="trajectory-colors">
                    <div class="color-item">
                        <div class="color-dot" style="background: #64ffda;"></div>
                        <span>Direct Path</span>
                    </div>
                    <div class="color-item">
                        <div class="color-dot" style="background: #ff6b6b;"></div>
                        <span>Upper Route</span>
                    </div>
                    <div class="color-item">
                        <div class="color-dot" style="background: #4ecdc4;"></div>
                        <span>Lower Route</span>
                    </div>
                    <div class="color-item">
                        <div class="color-dot" style="background: #ffe66d;"></div>
                        <span>Exploratory</span>
                    </div>
                </div>
                
                <canvas id="canvas" width="700" height="500"></canvas>
                
                <div class="status" id="status">Ready to start multi-scenario gradient-based path planning...</div>
            </div>
            
            <div class="math-panel">
                <div class="phase-indicator">
                    <div class="phase-name" id="phaseName">Initialization</div>
                    <div class="phase-description" id="phaseDesc">Setting up multiple trajectory scenarios</div>
                </div>
                
                <div class="math-section">
                    <div class="math-title">📊 Global Parameters</div>
                    <div class="values-grid">
                        <div class="value-box">
                            <div class="value-label">Timestep t</div>
                            <div class="value-number" id="timestepValue">0</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Noise Level σ(t)</div>
                            <div class="value-number" id="noiseLevelValue">1.000</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Progress %</div>
                            <div class="value-number" id="progressValue">0%</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Active Trajectories</div>
                            <div class="value-number" id="activeTrajectories">4</div>
                        </div>
                    </div>
                </div>
                
                <div class="math-section">
                    <div class="math-title">⚡ Score Function: ∇ log p(x|t)</div>
                    <div class="formula" id="scoreFormula">
                        ∇ log p(x|t) = α(t)·∇goal + β(t)·∇obstacle + γ(t)·∇boundary + δ(t)·∇momentum + ε(t)·∇smoothness
                    </div>
                    <div class="values-grid">
                        <div class="value-box">
                            <div class="value-label">Goal Weight α(t)</div>
                            <div class="value-number" id="goalWeight">0.200</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Obstacle Weight β(t)</div>
                            <div class="value-number" id="obstacleWeight">1.000</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Boundary Weight γ(t)</div>
                            <div class="value-number" id="boundaryWeight">0.010</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Momentum Weight δ(t)</div>
                            <div class="value-number" id="momentumWeight">0.000</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Smoothness Weight ε(t)</div>
                            <div class="value-number" id="smoothnessWeight">0.050</div>
                        </div>
                    </div>
                </div>
                
                <div class="math-section">
                    <div class="math-title">🎯 Trajectory Analysis</div>
                    <div id="trajectoryAnalysis">
                        <div class="trajectory-item" id="traj0">
                            <div style="color: #64ffda; font-weight: bold;">Direct Path</div>
                            <div class="values-grid">
                                <div class="value-box">
                                    <div class="value-label">Goal Distance</div>
                                    <div class="value-number" id="goalDist0">700.0</div>
                                </div>
                                <div class="value-box">
                                    <div class="value-label">Obstacle Force</div>
                                    <div class="value-number" id="obstForce0">0.00</div>
                                </div>
                                <div class="value-box">
                                    <div class="value-label">Path Length</div>
                                    <div class="value-number" id="pathLength0">0.0</div>
                                </div>
                                <div class="value-box">
                                    <div class="value-label">Smoothness</div>
                                    <div class="value-number" id="smoothness0">0.00</div>
                                </div>
                            </div>
                        </div>
                        <div class="trajectory-item" id="traj1" style="margin-top: 10px;">
                            <div style="color: #ff6b6b; font-weight: bold;">Upper Route</div>
                            <div class="values-grid">
                                <div class="value-box">
                                    <div class="value-label">Goal Distance</div>
                                    <div class="value-number" id="goalDist1">700.0</div>
                                </div>
                                <div class="value-box">
                                    <div class="value-label">Obstacle Force</div>
                                    <div class="value-number" id="obstForce1">0.00</div>
                                </div>
                                <div class="value-box">
                                    <div class="value-label">Path Length</div>
                                    <div class="value-number" id="pathLength1">0.0</div>
                                </div>
                                <div class="value-box">
                                    <div class="value-label">Smoothness</div>
                                    <div class="value-number" id="smoothness1">0.00</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="math-section">
                    <div class="math-title">🔄 Denoising Update Rule</div>
                    <div class="formula">
                        x_{t-1} = x_t + ε·∇ log p(x_t|t) + √(2ε)·z
                    </div>
                    <div class="values-grid">
                        <div class="value-box">
                            <div class="value-label">Step Size ε</div>
                            <div class="value-number" id="stepSize">0.100</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Noise Scale √(2ε)</div>
                            <div class="value-number" id="noiseScale">0.447</div>
                        </div>
                    </div>
                </div>
                
                <div class="math-section">
                    <div class="math-title">📈 Performance Metrics</div>
                    <div class="values-grid">
                        <div class="value-box">
                            <div class="value-label">Avg Path Quality</div>
                            <div class="value-number" id="avgQuality">0.00</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Convergence Rate</div>
                            <div class="value-number" id="convergenceRate">0.00</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Diversity Score</div>
                            <div class="value-number" id="diversityScore">1.00</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Success Rate</div>
                            <div class="value-number" id="successRate">0%</div>
                        </div>
                    </div>
                </div>
                
                <div class="math-section">
                    <div class="math-title">📐 Dynamic Gradient Field</div>
                    <div class="formula">
                        ∇(t) = (1 - e^{-λt})·∇final + e^{-λt}·∇initial
                    </div>
                    <div class="values-grid">
                        <div class="value-box">
                            <div class="value-label">Field Adaptation λ</div>
                            <div class="value-number" id="fieldAdaptation">0.100</div>
                        </div>
                        <div class="value-box">
                            <div class="value-label">Field Resolution</div>
                            <div class="value-number" id="fieldResolution">15×10</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Animation state
        let animationId;
        let isAnimating = false;
        let showGradient = true;
        let showParticles = true;
        let timestep = 0;
        let maxTimesteps = 100;
        let speedMultiplier = 3;
        let goalAttractionMultiplier = 5;
        let gradientField = [];
        let gradientFieldResolution = { x: 15, y: 10 };
        let maxParticles = 80;
        
        // Environment setup
        const start = {x: 50, y: 250};
        let goals = [{x: 650, y: 250}];
        let obstacles = [
            {x: 180, y: 120, width: 80, height: 150, type: 'rectangle', color: '#ff6b6b'},
            {x: 350, y: 200, width: 60, height: 120, type: 'ellipse', color: '#f368e0'},
            {x: 500, y: 80, width: 70, height: 140, type: 'polygon', color: '#ff9f43'}
        ];
        
        // Multiple trajectory scenarios
        const trajectoryScenarios = [
            {
                name: "Direct Path",
                color: "#64ffda",
                points: [],
                originalPoints: [],
                startOffset: {x: 0, y: 0},
                strategy: "direct",
                momentum: {x: 0, y: 0}
            },
            {
                name: "Upper Route",
                color: "#ff6b6b",
                points: [],
                originalPoints: [],
                startOffset: {x: 0, y: -50},
                strategy: "upper",
                momentum: {x: 0, y: 0}
            },
            {
                name: "Lower Route",
                color: "#4ecdc4",
                points: [],
                originalPoints: [],
                startOffset: {x: 0, y: 50},
                strategy: "lower",
                momentum: {x: 0, y: 0}
            },
            {
                name: "Exploratory",
                color: "#ffe66d",
                points: [],
                originalPoints: [],
                startOffset: {x: 0, y: 0},
                strategy: "exploratory",
                momentum: {x: 0, y: 0}
            }
        ];
        
        let flowParticles = [];
        let mathMetrics = {
            goalWeight: 0.2,
            obstacleWeight: 1.0,
            boundaryWeight: 0.01,
            momentumWeight: 0.0,
            smoothnessWeight: 0.05,
            stepSize: 0.1,
            noiseScale: 0.447,
            fieldAdaptation: 0.1
        };
        
        // Check if point is inside any obstacle
        function isPointInObstacle(x, y) {
            for (const obs of obstacles) {
                if (obs.type === 'rectangle') {
                    if (x > obs.x && x < obs.x + obs.width &&
                        y > obs.y && y < obs.y + obs.height) {
                        return true;
                    }
                } else if (obs.type === 'ellipse') {
                    const centerX = obs.x + obs.width/2;
                    const centerY = obs.y + obs.height/2;
                    const radiusX = obs.width/2;
                    const radiusY = obs.height/2;
                    const normalizedX = (x - centerX) / radiusX;
                    const normalizedY = (y - centerY) / radiusY;
                    if (normalizedX * normalizedX + normalizedY * normalizedY <= 1) {
                        return true;
                    }
                } else if (obs.type === 'polygon') {
                    // Simple hexagon test
                    const centerX = obs.x + obs.width/2;
                    const centerY = obs.y + obs.height/2;
                    const vertices = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3;
                        vertices.push({
                            x: centerX + obs.width/2 * Math.cos(angle),
                            y: centerY + obs.height/2 * Math.sin(angle)
                        });
                    }
                    
                    let inside = false;
                    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                        const xi = vertices[i].x, yi = vertices[i].y;
                        const xj = vertices[j].x, yj = vertices[j].y;
                        
                        const intersect = ((yi > y) !== (yj > y))
                            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                        if (intersect) inside = !inside;
                    }
                    
                    if (inside) return true;
                }
            }
            return false;
        }
        
        // Initialize all trajectory scenarios with proper diffusion from source
        function initializeTrajectories() {
            trajectoryScenarios.forEach(scenario => {
                scenario.points = [];
                scenario.originalPoints = [];
                scenario.momentum = {x: 0, y: 0};
                
                const numPoints = 25;
                const startPos = {
                    x: start.x + scenario.startOffset.x,
                    y: start.y + scenario.startOffset.y
                };
                
                // Start with just the start point
                scenario.points.push({x: startPos.x, y: startPos.y});
                
                // Add random points diffusing from the source
                for (let i = 1; i < numPoints; i++) {
                    let x, y;
                    let attempts = 0;
                    const maxAttempts = 100;
                    
                    do {
                        // Random direction from previous point
                        const prevPoint = scenario.points[i-1];
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 20 + Math.random() * 40;
                        
                        x = prevPoint.x + Math.cos(angle) * distance;
                        y = prevPoint.y + Math.sin(angle) * distance;
                        
                        // Keep within bounds
                        x = Math.max(50, Math.min(x, canvas.width - 50));
                        y = Math.max(50, Math.min(y, canvas.height - 50));
                        
                        attempts++;
                    } while (isPointInObstacle(x, y) && attempts < maxAttempts);
                    
                    // If we couldn't find a non-colliding point, just use a random position
                    if (attempts >= maxAttempts) {
                        x = startPos.x + (Math.random() - 0.5) * 200;
                        y = startPos.y + (Math.random() - 0.5) * 200;
                    }
                    
                    scenario.points.push({x, y});
                }
                
                // Store original points for reference
                scenario.originalPoints = JSON.parse(JSON.stringify(scenario.points));
            });
            
            addNoise();
            initializeGradientField();
        }
        
        function addNoise() {
            const noiseLevel = parseInt(document.getElementById('noiseSlider').value) / 100;
            
            trajectoryScenarios.forEach(scenario => {
                for (let i = 1; i < scenario.points.length; i++) {
                    const noise = noiseLevel * 60;
                    scenario.points[i].x = scenario.originalPoints[i].x + (Math.random() - 0.5) * noise;
                    scenario.points[i].y = scenario.originalPoints[i].y + (Math.random() - 0.5) * noise;
                    
                    // Ensure points don't end up inside obstacles after adding noise
                    if (isPointInObstacle(scenario.points[i].x, scenario.points[i].y)) {
                        // Push point out of obstacle
                        let dx = 0, dy = 0;
                        for (const obs of obstacles) {
                            if (scenario.points[i].x > obs.x && scenario.points[i].x < obs.x + obs.width &&
                                scenario.points[i].y > obs.y && scenario.points[i].y < obs.y + obs.height) {
                                // Find closest edge
                                const leftDist = scenario.points[i].x - obs.x;
                                const rightDist = (obs.x + obs.width) - scenario.points[i].x;
                                const topDist = scenario.points[i].y - obs.y;
                                const bottomDist = (obs.y + obs.height) - scenario.points[i].y;
                                
                                const minDist = Math.min(leftDist, rightDist, topDist, bottomDist);
                                
                                if (minDist === leftDist) {
                                    dx = -(leftDist + 5);
                                } else if (minDist === rightDist) {
                                    dx = rightDist + 5;
                                } else if (minDist === topDist) {
                                    dy = -(topDist + 5);
                                } else {
                                    dy = bottomDist + 5;
                                }
                                
                                scenario.points[i].x += dx;
                                scenario.points[i].y += dy;
                                break;
                            }
                        }
                    }
                }
            });
        }
        
        // Initialize dynamic gradient field
        function initializeGradientField() {
            gradientField = [];
            const cellWidth = canvas.width / (gradientFieldResolution.x + 1);
            const cellHeight = canvas.height / (gradientFieldResolution.y + 1);
            
            for (let i = 0; i <= gradientFieldResolution.x; i++) {
                gradientField[i] = [];
                for (let j = 0; j <= gradientFieldResolution.y; j++) {
                    const x = i * cellWidth + cellWidth/2;
                    const y = j * cellHeight + cellHeight/2;
                    
                    // Skip points inside obstacles
                    if (isPointInObstacle(x, y)) {
                        gradientField[i][j] = {
                            x: x,
                            y: y,
                            grad: {x: 0, y: 0},
                            targetGrad: {x: 0, y: 0},
                            inObstacle: true
                        };
                    } else {
                        gradientField[i][j] = {
                            x: x,
                            y: y,
                            grad: {x: 0, y: 0},
                            targetGrad: {x: 0, y: 0},
                            inObstacle: false
                        };
                    }
                }
            }
            updateGradientFieldTargets();
        }
        
        // Update gradient field targets based on current state
        function updateGradientFieldTargets() {
            const progress = timestep / maxTimesteps;
            
            for (let i = 0; i <= gradientFieldResolution.x; i++) {
                for (let j = 0; j <= gradientFieldResolution.y; j++) {
                    const cell = gradientField[i][j];
                    if (cell.inObstacle) continue;
                    
                    const grad = calculateGradient(cell.x, cell.y, timestep);
                    cell.targetGrad = grad;
                    
                    // Apply dynamic adaptation
                    const adaptationRate = mathMetrics.fieldAdaptation * (1 + progress * 2);
                    cell.grad.x += (grad.x - cell.grad.x) * adaptationRate;
                    cell.grad.y += (grad.y - cell.grad.y) * adaptationRate;
                }
            }
        }
        
        // Calculate dynamic gradient with real-time parameter updates
        function calculateGradient(x, y, currentTimestep = timestep) {
            const progress = currentTimestep / maxTimesteps;
            const noiseLevel = Math.exp(-progress * 3);
            
            // Update mathematical parameters dynamically
            mathMetrics.goalWeight = (0.2 + (1 - noiseLevel) * 0.8) * goalAttractionMultiplier;
            mathMetrics.obstacleWeight = 1.0 + (1 - noiseLevel) * 2.0;
            mathMetrics.boundaryWeight = 0.01 + (1 - noiseLevel) * 0.05;
            mathMetrics.momentumWeight = progress > 0.3 ? (1 - noiseLevel) * 0.3 : 0;
            mathMetrics.smoothnessWeight = 0.05 + (1 - noiseLevel) * 0.1;
            mathMetrics.stepSize = 0.1;
            mathMetrics.noiseScale = Math.sqrt(2 * mathMetrics.stepSize);
            mathMetrics.fieldAdaptation = 0.1 + progress * 0.2;
            
            let gradX = 0;
            let gradY = 0;
            let totalObstacleForce = 0;
            
            // Goal attraction - becomes stronger over time
            let minGoalDist = Infinity;
            for (const g of goals) {
                const goalDist = Math.sqrt((x - g.x) ** 2 + (y - g.y) ** 2);
                if (goalDist < minGoalDist) {
                    minGoalDist = goalDist;
                }
            }
            
            if (minGoalDist < Infinity) {
                // Gradually increase goal attraction over time
                const goalStrength = mathMetrics.goalWeight * (1 - noiseLevel) * (1 + progress * 5);
                for (const g of goals) {
                    const goalDist = Math.sqrt((x - g.x) ** 2 + (y - g.y) ** 2);
                    if (goalDist > 0) {
                        gradX += (g.x - x) / goalDist * goalStrength / goals.length;
                        gradY += (g.y - y) / goalDist * goalStrength / goals.length;
                    }
                }
            }
            
            // Obstacle repulsion - stronger and more precise
            obstacles.forEach(obs => {
                let nearestX, nearestY;
                
                if (obs.type === 'rectangle') {
                    nearestX = Math.max(obs.x, Math.min(x, obs.x + obs.width));
                    nearestY = Math.max(obs.y, Math.min(y, obs.y + obs.height));
                } else if (obs.type === 'ellipse') {
                    const centerX = obs.x + obs.width/2;
                    const centerY = obs.y + obs.height/2;
                    const radiusX = obs.width/2;
                    const radiusY = obs.height/2;
                    
                    // Find nearest point on ellipse
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const angle = Math.atan2(dy * radiusX, dx * radiusY);
                    nearestX = centerX + radiusX * Math.cos(angle);
                    nearestY = centerY + radiusY * Math.sin(angle);
                } else if (obs.type === 'polygon') {
                    const centerX = obs.x + obs.width/2;
                    const centerY = obs.y + obs.height/2;
                    const vertices = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3;
                        vertices.push({
                            x: centerX + obs.width/2 * Math.cos(angle),
                            y: centerY + obs.height/2 * Math.sin(angle)
                        });
                    }
                    
                    // Find nearest point on polygon (simplified)
                    let minDist = Infinity;
                    let nearestPoint = {x: centerX, y: centerY};
                    
                    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                        const segStart = vertices[j];
                        const segEnd = vertices[i];
                        
                        const segVecX = segEnd.x - segStart.x;
                        const segVecY = segEnd.y - segStart.y;
                        const segLength = Math.sqrt(segVecX * segVecX + segVecY * segVecY);
                        const segUnitX = segVecX / segLength;
                        const segUnitY = segVecY / segLength;
                        
                        const pointVecX = x - segStart.x;
                        const pointVecY = y - segStart.y;
                        
                        let proj = pointVecX * segUnitX + pointVecY * segUnitY;
                        proj = Math.max(0, Math.min(segLength, proj));
                        
                        const projX = segStart.x + segUnitX * proj;
                        const projY = segStart.y + segUnitY * proj;
                        
                        const dist = Math.sqrt((x - projX) ** 2 + (y - projY) ** 2);
                        
                        if (dist < minDist) {
                            minDist = dist;
                            nearestPoint = {x: projX, y: projY};
                        }
                    }
                    
                    nearestX = nearestPoint.x;
                    nearestY = nearestPoint.y;
                }
                
                const distX = x - nearestX;
                const distY = y - nearestY;
                const dist = Math.sqrt(distX * distX + distY * distY);
                
                if (dist < 200) {
                    // Stronger repulsion that increases as we get closer
                    const strength = mathMetrics.obstacleWeight * (200 - dist) / (dist + 1);
                    totalObstacleForce += strength;
                    
                    if (dist > 0) {
                        gradX += (x - nearestX) / dist * strength;
                        gradY += (y - nearestY) / dist * strength;
                    } else {
                        // If exactly on edge, push in a random direction
                        gradX += (Math.random() - 0.5) * strength;
                        gradY += (Math.random() - 0.5) * strength;
                    }
                }
            });
            
            // Boundary forces
            if (x < 80) gradX += (80 - x) * mathMetrics.boundaryWeight;
            if (x > canvas.width - 80) gradX += (canvas.width - 80 - x) * mathMetrics.boundaryWeight;
            if (y < 80) gradY += (80 - y) * mathMetrics.boundaryWeight;
            if (y > canvas.height - 80) gradY += (canvas.height - 80 - y) * mathMetrics.boundaryWeight;
            
            return {
                x: gradX, 
                y: gradY, 
                goalDist: minGoalDist,
                obstacleForce: totalObstacleForce
            };
        }
        
        // Update all trajectories with proper diffusion and guidance
        function updateTrajectories() {
            const progress = timestep / maxTimesteps;
            const noiseLevel = Math.exp(-progress * 3);
            
            trajectoryScenarios.forEach(scenario => {
                for (let i = 1; i < scenario.points.length; i++) {
                    const point = scenario.points[i];
                    let grad = calculateGradient(point.x, point.y);
                    
                    // If point is inside an obstacle, push it out first
                    if (isPointInObstacle(point.x, point.y)) {
                        let dx = 0, dy = 0;
                        for (const obs of obstacles) {
                            if (point.x > obs.x && point.x < obs.x + obs.width &&
                                point.y > obs.y && point.y < obs.y + obs.height) {
                                // Find closest edge
                                const leftDist = point.x - obs.x;
                                const rightDist = (obs.x + obs.width) - point.x;
                                const topDist = point.y - obs.y;
                                const bottomDist = (obs.y + obs.height) - point.y;
                                
                                const minDist = Math.min(leftDist, rightDist, topDist, bottomDist);
                                
                                if (minDist === leftDist) {
                                    dx = -(leftDist + 5);
                                } else if (minDist === rightDist) {
                                    dx = rightDist + 5;
                                } else if (minDist === topDist) {
                                    dy = -(topDist + 5);
                                } else {
                                    dy = bottomDist + 5;
                                }
                                
                                point.x += dx;
                                point.y += dy;
                                break;
                            }
                        }
                        // Recalculate gradient after moving out of obstacle
                        grad = calculateGradient(point.x, point.y);
                    }
                    
                    // Apply momentum
                    scenario.momentum.x = scenario.momentum.x * 0.9 + grad.x * mathMetrics.stepSize;
                    scenario.momentum.y = scenario.momentum.y * 0.9 + grad.y * mathMetrics.stepSize;
                    
                    // Update position with momentum
                    point.x += scenario.momentum.x * mathMetrics.momentumWeight;
                    point.y += scenario.momentum.y * mathMetrics.momentumWeight;
                    
                    // Main gradient update - stronger toward the end
                    const gradientStrength = 1 + progress * 2;
                    point.x += grad.x * mathMetrics.stepSize * gradientStrength;
                    point.y += grad.y * mathMetrics.stepSize * gradientStrength;
                    
                    // Add noise based on current noise level
                    if (noiseLevel > 0.01) {
                        point.x += (Math.random() - 0.5) * mathMetrics.noiseScale * noiseLevel * 10;
                        point.y += (Math.random() - 0.5) * mathMetrics.noiseScale * noiseLevel * 10;
                    }
                    
                    // Smoothing - but only if it doesn't push us into obstacles
                    if (i > 1) {
                        const prev = scenario.points[i - 1];
                        const next = scenario.points[Math.min(i + 1, scenario.points.length - 1)];
                        
                        const smoothX = ((prev.x + next.x) / 2 - point.x) * mathMetrics.smoothnessWeight;
                        const smoothY = ((prev.y + next.y) / 2 - point.y) * mathMetrics.smoothnessWeight;
                        
                        // Only apply smoothing if it doesn't push into obstacle
                        const newX = point.x + smoothX;
                        const newY = point.y + smoothY;
                        
                        if (!isPointInObstacle(newX, newY)) {
                            point.x += smoothX;
                            point.y += smoothY;
                        }
                    }
                }
            });
        }
        
        // Calculate trajectory metrics
        function calculateTrajectoryMetrics(scenario) {
            const points = scenario.points;
            if (points.length < 2) return {pathLength: 0, smoothness: 0, goalDist: 0, obstForce: 0};
            
            let pathLength = 0;
            let smoothness = 0;
            let avgObstacleForce = 0;
            let collisionCount = 0;
            
            // Calculate distance to nearest goal from the last point
            const lastPoint = points[points.length - 1];
            let minGoalDist = Infinity;
            for (const g of goals) {
                const dist = Math.sqrt((lastPoint.x - g.x) ** 2 + (lastPoint.y - g.y) ** 2);
                if (dist < minGoalDist) {
                    minGoalDist = dist;
                }
            }
            let goalDist = minGoalDist;
            
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                pathLength += Math.sqrt(dx * dx + dy * dy);
                
                if (i > 1) {
                    const prev = points[i-2];
                    const curr = points[i-1];
                    const next = points[i];
                    
                    const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                    const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                    const angleDiff = Math.abs(angle2 - angle1);
                    smoothness += angleDiff;
                }
                
                const grad = calculateGradient(points[i].x, points[i].y);
                avgObstacleForce += grad.obstacleForce;
                
                // Check for collisions
                if (isPointInObstacle(points[i].x, points[i].y)) {
                    collisionCount++;
                }
            }
            
            // Penalize paths that go through obstacles
            const collisionPenalty = collisionCount > 0 ? 100 * collisionCount : 0;
            goalDist += collisionPenalty;
            
            return {
                pathLength: pathLength.toFixed(1),
                smoothness: (smoothness / points.length).toFixed(2),
                goalDist: goalDist.toFixed(1),
                obstForce: (avgObstacleForce / points.length).toFixed(2),
                collisionCount: collisionCount
            };
        }
        
        // Update math panel
        function updateMathPanel() {
            const progress = timestep / maxTimesteps;
            const noiseLevel = Math.exp(-progress * 3);
            
            // Update phase
            let phase, description;
            if (progress < 0.3) {
                phase = "Diffusion Phase";
                description = "High noise, random exploration from source";
            } else if (progress < 0.7) {
                phase = "Guidance Phase";
                description = "Moderate noise, trajectories being guided toward goal";
            } else {
                phase = "Convergence Phase";
                description = "Low noise, strong goal attraction, final refinement";
            }
            
            document.getElementById('phaseName').textContent = phase;
            document.getElementById('phaseDesc').textContent = description;
            
            // Update global parameters
            document.getElementById('timestepValue').textContent = timestep;
            document.getElementById('noiseLevelValue').textContent = noiseLevel.toFixed(3);
            document.getElementById('progressValue').textContent = (progress * 100).toFixed(0) + '%';
            document.getElementById('activeTrajectories').textContent = trajectoryScenarios.length;
            document.getElementById('fieldAdaptation').textContent = mathMetrics.fieldAdaptation.toFixed(3);
            document.getElementById('fieldResolution').textContent = `${gradientFieldResolution.x}×${gradientFieldResolution.y}`;
            
            // Update score function weights
            document.getElementById('goalWeight').textContent = mathMetrics.goalWeight.toFixed(3);
            document.getElementById('obstacleWeight').textContent = mathMetrics.obstacleWeight.toFixed(3);
            document.getElementById('boundaryWeight').textContent = mathMetrics.boundaryWeight.toFixed(3);
            document.getElementById('momentumWeight').textContent = mathMetrics.momentumWeight.toFixed(3);
            document.getElementById('smoothnessWeight').textContent = mathMetrics.smoothnessWeight.toFixed(3);
            document.getElementById('stepSize').textContent = mathMetrics.stepSize.toFixed(3);
            document.getElementById('noiseScale').textContent = mathMetrics.noiseScale.toFixed(3);
            
            // Update trajectory analysis
            trajectoryScenarios.forEach((scenario, idx) => {
                if (idx <= 1) {
                    const metrics = calculateTrajectoryMetrics(scenario);
                    document.getElementById(`goalDist${idx}`).textContent = metrics.goalDist;
                    document.getElementById(`obstForce${idx}`).textContent = metrics.obstForce;
                    document.getElementById(`pathLength${idx}`).textContent = metrics.pathLength;
                    document.getElementById(`smoothness${idx}`).textContent = metrics.smoothness;
                }
            });
            
            // Calculate performance metrics
            let avgQuality = 0;
            let successCount = 0;
            let totalPathLength = 0;
            let diversitySum = 0;
            let collisionCount = 0;
            
            trajectoryScenarios.forEach(scenario => {
                const metrics = calculateTrajectoryMetrics(scenario);
                const quality = 1 / (1 + parseFloat(metrics.goalDist) / 100);
                avgQuality += quality;
                totalPathLength += parseFloat(metrics.pathLength);
                collisionCount += metrics.collisionCount;
                
                if (parseFloat(metrics.goalDist) < 50 && metrics.collisionCount === 0) {
                    successCount++;
                }
            });
            
            // Calculate diversity by comparing all pairs of trajectories
            for (let i = 0; i < trajectoryScenarios.length; i++) {
                for (let j = i + 1; j < trajectoryScenarios.length; j++) {
                    const traj1 = trajectoryScenarios[i].points;
                    const traj2 = trajectoryScenarios[j].points;
                    let diffSum = 0;
                    
                    for (let k = 0; k < Math.min(traj1.length, traj2.length); k++) {
                        diffSum += Math.sqrt(
                            Math.pow(traj1[k].x - traj2[k].x, 2) + 
                            Math.pow(traj1[k].y - traj2[k].y, 2)
                        );
                    }
                    
                    diversitySum += diffSum / Math.min(traj1.length, traj2.length);
                }
            }
            
            const pairCount = (trajectoryScenarios.length * (trajectoryScenarios.length - 1)) / 2;
            const avgDiversity = pairCount > 0 ? diversitySum / pairCount : 0;
            
            avgQuality /= trajectoryScenarios.length;
            const diversityScore = Math.min(1, avgDiversity / 100) * (1 - progress * 0.5);
            const convergenceRate = progress;
            
            document.getElementById('avgQuality').textContent = avgQuality.toFixed(2);
            document.getElementById('convergenceRate').textContent = convergenceRate.toFixed(2);
            document.getElementById('diversityScore').textContent = diversityScore.toFixed(2);
            document.getElementById('successRate').textContent = Math.round(successCount / trajectoryScenarios.length * 100) + '%';
            
            // Update status message
            let statusMsg = "";
            if (progress < 0.3) {
                statusMsg = "Diffusing trajectories randomly from source...";
            } else if (progress < 0.7) {
                statusMsg = "Guiding trajectories toward goal while avoiding obstacles...";
            } else {
                statusMsg = "Converging trajectories to optimal paths...";
            }
            
            if (collisionCount > 0) {
                statusMsg += ` (${collisionCount} obstacle collisions detected)`;
            }
            
            document.getElementById('status').textContent = statusMsg;
        }
        
        // Initialize flow particles
        function initializeFlowParticles() {
            flowParticles = [];
            for (let i = 0; i < maxParticles; i++) {
                let x, y;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                } while (isPointInObstacle(x, y));
                
                flowParticles.push({
                    x: x,
                    y: y,
                    life: Math.random() * 60,
                    maxLife: 60
                });
            }
        }
        
        function updateFlowParticles() {
            flowParticles.forEach(particle => {
                // Find nearest gradient field cell
                const cellX = Math.floor(particle.x / (canvas.width / (gradientFieldResolution.x + 1)));
                const cellY = Math.floor(particle.y / (canvas.height / (gradientFieldResolution.y + 1)));
                
                if (cellX >= 0 && cellX <= gradientFieldResolution.x && 
                    cellY >= 0 && cellY <= gradientFieldResolution.y) {
                    const cell = gradientField[cellX][cellY];
                    if (cell.inObstacle) {
                        // If particle is in obstacle cell, move it out
                        particle.x = Math.random() * canvas.width;
                        particle.y = Math.random() * canvas.height;
                        particle.life = particle.maxLife;
                        return;
                    }
                    
                    const grad = cell.grad;
                    
                    particle.x += grad.x * 1.5;
                    particle.y += grad.y * 1.5;
                    particle.life--;
                    
                    if (particle.life <= 0 || particle.x < 0 || particle.x > canvas.width || 
                        particle.y < 0 || particle.y > canvas.height || isPointInObstacle(particle.x, particle.y)) {
                        // Respawn particle in a valid location
                        do {
                            particle.x = Math.random() * canvas.width;
                            particle.y = Math.random() * canvas.height;
                        } while (isPointInObstacle(particle.x, particle.y));
                        particle.life = particle.maxLife;
                    }
                }
            });
        }
        
        // Drawing functions
        function drawBackground() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function drawObstacles() {
            obstacles.forEach(obs => {
                ctx.fillStyle = obs.color;
                ctx.shadowColor = obs.color;
                ctx.shadowBlur = 8;
                
                if (obs.type === 'rectangle') {
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                } else if (obs.type === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(
                        obs.x + obs.width/2, 
                        obs.y + obs.height/2, 
                        obs.width/2, 
                        obs.height/2, 
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                } else if (obs.type === 'polygon') {
                    ctx.beginPath();
                    const centerX = obs.x + obs.width/2;
                    const centerY = obs.y + obs.height/2;
                    for (let i = 0; i < 6; i++) {
                        const angle = i * Math.PI / 3;
                        const x = centerX + obs.width/2 * Math.cos(angle);
                        const y = centerY + obs.height/2 * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            });
            
            ctx.shadowBlur = 0;
        }
        
        function drawStartGoal() {
            ctx.shadowColor = '#a8e6cf';
            ctx.shadowBlur = 10;
            
            // Draw start
            ctx.fillStyle = '#a8e6cf';
            ctx.beginPath();
            ctx.arc(start.x, start.y, 12, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw goals
            ctx.fillStyle = '#ff9ff3';
            goals.forEach(g => {
                ctx.beginPath();
                ctx.arc(g.x, g.y, 12, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw star shape for additional goals
                if (goals.length > 1) {
                    ctx.fillStyle = '#feca57';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = i * Math.PI * 2 / 5 - Math.PI / 2;
                        const outerX = g.x + 15 * Math.cos(angle);
                        const outerY = g.y + 15 * Math.sin(angle);
                        const innerX = g.x + 7 * Math.cos(angle + Math.PI / 5);
                        const innerY = g.y + 7 * Math.sin(angle + Math.PI / 5);
                        
                        if (i === 0) {
                            ctx.moveTo(outerX, outerY);
                        } else {
                            ctx.lineTo(outerX, outerY);
                        }
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            });
            
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#fff';
            ctx.font = '11px Arial';
            ctx.fillText('START', start.x - 15, start.y - 20);
            
            if (goals.length === 1) {
                ctx.fillText('GOAL', goals[0].x - 12, goals[0].y - 20);
            } else {
                goals.forEach((g, idx) => {
                    ctx.fillText(`GOAL ${idx+1}`, g.x - 20, g.y - 20);
                });
            }
        }
        
        function drawTrajectories() {
            trajectoryScenarios.forEach(scenario => {
                // Draw points as individual dots
                scenario.points.forEach((point, idx) => {
                    if (idx > 0) {
                        ctx.fillStyle = scenario.color;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
            });
        }
        
        function drawGradientField() {
            const cellWidth = canvas.width / (gradientFieldResolution.x + 1);
            const cellHeight = canvas.height / (gradientFieldResolution.y + 1);
            const arrowSize = Math.min(cellWidth, cellHeight) * 0.3;
            
            for (let i = 0; i <= gradientFieldResolution.x; i++) {
                for (let j = 0; j <= gradientFieldResolution.y; j++) {
                    const cell = gradientField[i][j];
                    if (cell.inObstacle) continue;
                    
                    const gradLength = Math.sqrt(cell.grad.x * cell.grad.x + cell.grad.y * cell.grad.y);
                    
                    if (gradLength > 0) {
                        const normX = cell.grad.x / gradLength;
                        const normY = cell.grad.y / gradLength;
                        
                        // Color based on gradient strength
                        const strength = Math.min(1, gradLength * 5);
                        const hue = 120 + (1 - strength) * 120;
                        ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.7)`;
                        ctx.lineWidth = 1 + strength * 2;
                        
                        // Draw arrow
                        ctx.beginPath();
                        ctx.moveTo(cell.x, cell.y);
                        ctx.lineTo(
                            cell.x + normX * arrowSize, 
                            cell.y + normY * arrowSize
                        );
                        ctx.stroke();
                        
                        // Arrow head
                        ctx.beginPath();
                        ctx.moveTo(
                            cell.x + normX * arrowSize, 
                            cell.y + normY * arrowSize
                        );
                        ctx.lineTo(
                            cell.x + normX * arrowSize * 0.7 - normY * arrowSize * 0.3,
                            cell.y + normY * arrowSize * 0.7 + normX * arrowSize * 0.3
                        );
                        ctx.lineTo(
                            cell.x + normX * arrowSize * 0.7 + normY * arrowSize * 0.3,
                            cell.y + normY * arrowSize * 0.7 - normX * arrowSize * 0.3
                        );
                        ctx.closePath();
                        ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.7)`;
                        ctx.fill();
                    }
                }
            }
        }
        
        function drawFlowParticles() {
            flowParticles.forEach(particle => {
                const lifeRatio = particle.life / particle.maxLife;
                ctx.fillStyle = `rgba(100, 255, 218, ${lifeRatio * 0.7})`;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2 * lifeRatio, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        // Main animation loop
        function animate() {
            drawBackground();
            drawObstacles();
            
            if (showGradient) {
                drawGradientField();
            }
            
            if (showParticles) {
                drawFlowParticles();
            }
            
            drawTrajectories();
            drawStartGoal();
            
            // Update logic
            for (let i = 0; i < speedMultiplier; i++) {
                if (timestep < maxTimesteps) {
                    timestep++;
                    updateTrajectories();
                    updateFlowParticles();
                    updateGradientFieldTargets();
                    updateMathPanel();
                }
            }
            
            if (timestep < maxTimesteps) {
                animationId = requestAnimationFrame(animate);
            } else {
                isAnimating = false;
                document.getElementById('startBtn').textContent = "Restart";
                document.getElementById('status').textContent = "All scenarios completed!";
            }
        }
        
        // Add a new obstacle
        function addObstacle() {
            const types = ['rectangle', 'ellipse', 'polygon'];
            const colors = ['#ff6b6b', '#f368e0', '#ff9f43', '#54a0ff', '#00d2d3'];
            
            const type = types[Math.floor(Math.random() * types.length)];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const width = 50 + Math.random() * 100;
            const height = 50 + Math.random() * 100;
            const x = 100 + Math.random() * (canvas.width - 200);
            const y = 100 + Math.random() * (canvas.height - 200);
            
            obstacles.push({
                x: x,
                y: y,
                width: width,
                height: height,
                type: type,
                color: color
            });
            
            if (isAnimating) {
                initializeGradientField();
            } else {
                initializeTrajectories();
                animate();
                cancelAnimationFrame(animationId);
            }
        }
        
        // Remove the last obstacle
        function removeObstacle() {
            if (obstacles.length > 0) {
                obstacles.pop();
                
                if (isAnimating) {
                    initializeGradientField();
                } else {
                    initializeTrajectories();
                    animate();
                    cancelAnimationFrame(animationId);
                }
            }
        }
        
        // Add a new goal
        function addGoal() {
            let x, y;
            let attempts = 0;
            const maxAttempts = 100;
            
            do {
                x = 100 + Math.random() * (canvas.width - 200);
                y = 100 + Math.random() * (canvas.height - 200);
                attempts++;
            } while (isPointInObstacle(x, y) && attempts < maxAttempts);
            
            if (attempts < maxAttempts) {
                goals.push({x: x, y: y});
                
                if (!isAnimating) {
                    initializeTrajectories();
                    animate();
                    cancelAnimationFrame(animationId);
                }
            }
        }
        
        // Clear all goals except the first one
        function clearGoals() {
            if (goals.length > 1) {
                goals = [goals[0]];
                
                if (!isAnimating) {
                    initializeTrajectories();
                    animate();
                    cancelAnimationFrame(animationId);
                }
            }
        }
        
        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            if (isAnimating) {
                cancelAnimationFrame(animationId);
                isAnimating = false;
                document.getElementById('startBtn').textContent = "Resume";
                document.getElementById('status').textContent = "Paused...";
            } else {
                if (timestep >= maxTimesteps) {
                    // Reset if completed
                    timestep = 0;
                    initializeTrajectories();
                    initializeFlowParticles();
                }
                isAnimating = true;
                document.getElementById('startBtn').textContent = "Pause";
                animate();
            }
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            cancelAnimationFrame(animationId);
            isAnimating = false;
            timestep = 0;
            initializeTrajectories();
            initializeFlowParticles();
            updateMathPanel();
            document.getElementById('startBtn').textContent = "Start All Scenarios";
            document.getElementById('status').textContent = "Ready to start multi-scenario gradient-based path planning...";
            animate(); // Draw once
            cancelAnimationFrame(animationId); // Stop after one frame
        });
        
        document.getElementById('showGradientBtn').addEventListener('click', () => {
            showGradient = !showGradient;
        });
        
        document.getElementById('showParticlesBtn').addEventListener('click', () => {
            showParticles = !showParticles;
        });
        
        document.getElementById('noiseSlider').addEventListener('input', (e) => {
            document.getElementById('noiseValue').textContent = e.target.value + '%';
            if (!isAnimating) {
                initializeTrajectories();
                animate(); // Draw once
                cancelAnimationFrame(animationId); // Stop after one frame
            }
        });
        
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            speedMultiplier = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = e.target.value + 'x';
        });
        
        document.getElementById('goalAttractionSlider').addEventListener('input', (e) => {
            goalAttractionMultiplier = parseInt(e.target.value);
            document.getElementById('goalAttractionValue').textContent = e.target.value + 'x';
        });
        
        document.getElementById('particlesSlider').addEventListener('input', (e) => {
            maxParticles = parseInt(e.target.value);
            document.getElementById('particlesValue').textContent = e.target.value;
            if (!isAnimating) {
                initializeFlowParticles();
                animate(); // Draw once
                cancelAnimationFrame(animationId); // Stop after one frame
            }
        });
        
        document.getElementById('addObstacleBtn').addEventListener('click', addObstacle);
        document.getElementById('removeObstacleBtn').addEventListener('click', removeObstacle);
        document.getElementById('addGoalBtn').addEventListener('click', addGoal);
        document.getElementById('clearGoalsBtn').addEventListener('click', clearGoals);
        
        // Initialize
        initializeTrajectories();
        initializeFlowParticles();
        updateMathPanel();
        animate(); // Draw once
        cancelAnimationFrame(animationId); // Stop after one frame
    </script>
</body>
</html>